import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { BlogService, BlogPost, PostRevision, SEOScore, SEOSuggestion, SocialMeta } from '../../services/blog.service';
import { AuthService } from '../../services/auth.service';

interface ContentSection {
  heading: string;
  content: string;
}

@Component({
  selector: 'app-admin-blog-form',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './admin-blog-form.component.html',
  styleUrls: ['./admin-blog-form.component.scss']
})
export class AdminBlogFormComponent implements OnInit, OnDestroy {
  Math = Math; // Make Math available to template
  
  form!: FormGroup;
  isEdit = false;
  postId: string | null = null;
  loading = false;
  submitted = false;
  error: string | null = null;
  success: string | null = null;
  savingBlog = false;
  autoSaving = false;
  lastAutoSaveTime: string | null = null;

  imagePreview: string | null = null;
  fileUploadError: string | null = null;

  contentSections: ContentSection[] = [{ heading: '', content: '' }];
  tags: string[] = [];
  tagInput = '';

  showPreview = false;
  scheduleForLater = false;
  autoSaveInterval: any = null;
  AUTO_SAVE_INTERVAL = 60000; // Auto-save every 60 seconds

  totalWordCount = 0;
  sectionWordCounts: number[] = [0];
  
  metaDescriptionAutoGenerated = true; // Track if meta was auto-generated

  // Revision history
  revisions: PostRevision[] = [];
  revisionsLoading = false;
  showRevisionHistory = false;
  selectedRevision: PostRevision | null = null;
  restoring = false;

  // SEO Preview
  showSEOPreview = false;
  seoScore: SEOScore | null = null;
  previewSlug = '';
  siteUrl = 'sorella-home-solutions.com';

  // Social Meta Tags
  showSocialPreview = false;
  socialMeta: SocialMeta = {
    ogTitle: '',
    ogDescription: '',
    ogImage: '',
    twitterTitle: '',
    twitterDescription: '',
    twitterImage: '',
    linkedinTitle: '',
    linkedinDescription: '',
    linkedinImage: ''
  };
  activeSocialPlatform: 'facebook' | 'twitter' | 'linkedin' = 'facebook';
  socialImagePreview: string | null = null;
  useCustomSocialImage = false;

  // JSON-LD Schema Preview
  showJSONLDPreview = false;
  jsonLdPreviewRaw = '';
  jsonLdPreviewFormatted = '';

  categories = [
    'Seasonal Care',
    'Move Management',
    'Home Care',
    'Concierge',
    'Corporate Relocation',
    'Tips & Advice'
  ];

  constructor(
    private formBuilder: FormBuilder,
    private blogService: BlogService,
    private authService: AuthService,
    private route: ActivatedRoute,
    private router: Router
  ) {}

  ngOnInit(): void {
    this.initializeForm();
    this.calculateWordCounts();

    this.route.params.subscribe(params => {
      if (params['id'] && params['id'] !== 'new') {
        this.isEdit = true;
        this.postId = params['id'];
        this.loadPost();
      } else {
        // For new posts, start autosave after form is initialized
        this.startAutoSave();
      }
    });

    // Set up word count calculations and meta description auto-generation
    this.form.valueChanges.subscribe(() => {
      this.calculateWordCounts();
    });

    // Auto-generate meta description from intro text
    this.form.get('introText')?.valueChanges.subscribe(() => {
      this.autoGenerateMetaDescription();
    });

    // Update SEO score as form values change
    this.form.valueChanges.subscribe(() => {
      this.calculateSEOScore();
    });

    // Initial SEO score calculation
    this.calculateSEOScore();
  }

  ngOnDestroy(): void {
    this.stopAutoSave();
  }

  initializeForm(): void {
    this.form = this.formBuilder.group({
      title: ['', [Validators.required, Validators.minLength(5), Validators.maxLength(200)]],
      subtitle: ['', [Validators.required, Validators.minLength(5), Validators.maxLength(300)]],
      author: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      category: ['', Validators.required],
      featuredImage: ['', Validators.required],
      introText: ['', [Validators.required, Validators.minLength(10), Validators.maxLength(1000)]],
      metaDescription: ['', [Validators.maxLength(160)]],
      published: [true],
      publishDate: [''],
      featured: [false]
    });
  }

  loadPost(): void {
    this.loading = true;
    this.error = null;

    this.blogService.getPost(this.postId!).subscribe({
      next: (response) => {
        // Handle both response formats (with or without data wrapper)
        const post = response.data || response;
        
        if (!post || !post.title) {
          throw new Error('Invalid post data');
        }

        this.form.patchValue({
          title: post.title,
          subtitle: post.subtitle || '',
          author: post.author || '',
          category: post.category || '',
          featuredImage: post.featuredImage || '',
          introText: post.introText || '',
          metaDescription: post.metaDescription || '',
          published: post.published !== undefined ? post.published : true,
          publishDate: post.publishDate ? this.formatDateForInput(new Date(post.publishDate)) : '',
          featured: post.featured || false
        });

        this.imagePreview = post.featuredImage || null;
        this.contentSections = post.contentSections && post.contentSections.length > 0 
          ? post.contentSections 
          : [{ heading: '', content: '' }];
        this.tags = post.tags || [];
        this.scheduleForLater = !!post.publishDate;
        this.lastAutoSaveTime = post.lastAutoSavedAt ? new Date(post.lastAutoSavedAt).toLocaleString() : null;
        
        // If the post has a meta description, treat it as manually edited
        this.metaDescriptionAutoGenerated = !post.metaDescription;

        // Load social meta tags
        if (post.socialMeta) {
          this.socialMeta = post.socialMeta;
          this.socialImagePreview = post.socialMeta.ogImage || post.featuredImage || null;
        } else {
          // Auto-generate social meta if not present
          this.generateAndSetSocialMeta(post);
        }

        this.calculateWordCounts();
        this.startAutoSave();
        this.loadRevisions();
        this.loading = false;
      },
      error: (error) => {
        this.error = 'Failed to load blog post. The post may have been deleted.';
        this.loading = false;
        console.error('Error loading post:', error);
      }
    });
  }

  loadRevisions(): void {
    if (!this.postId || this.postId === 'new') return;

    this.revisionsLoading = true;
    this.blogService.getPostRevisions(this.postId).subscribe({
      next: (response) => {
        this.revisions = response.data || [];
        this.revisionsLoading = false;
      },
      error: (error) => {
        console.error('Error loading revisions:', error);
        this.revisionsLoading = false;
      }
    });
  }

  get f() {
    return this.form.controls;
  }

  onImageSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];

    if (!file) return;

    // Validate file type
    if (!file.type.startsWith('image/')) {
      this.fileUploadError = 'Please select a valid image file';
      return;
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      this.fileUploadError = 'File size must be less than 5MB';
      return;
    }

    this.fileUploadError = null;

    // Create preview
    const reader = new FileReader();
    reader.onload = () => {
      this.imagePreview = reader.result as string;
      this.form.patchValue({ featuredImage: this.imagePreview });
    };
    reader.readAsDataURL(file);
  }

  removeImage(): void {
    this.imagePreview = null;
    this.form.patchValue({ featuredImage: '' });
  }

  addTag(): void {
    const tag = this.tagInput.trim();
    if (tag && !this.tags.includes(tag)) {
      this.tags.push(tag);
      this.tagInput = '';
    }
  }

  removeTag(tag: string): void {
    this.tags = this.tags.filter(t => t !== tag);
  }

  addContentSection(): void {
    this.contentSections.push({ heading: '', content: '' });
  }

  removeContentSection(index: number): void {
    if (this.contentSections.length > 1) {
      this.contentSections.splice(index, 1);
    }
  }

  updateContentSection(index: number, field: 'heading' | 'content', value: string): void {
    this.contentSections[index][field] = value;
  }

  saveBlog(): void {
    this.submitted = true;
    this.error = null;
    this.success = null;

    // Validate form and get specific error messages
    const validationError = this.getFormValidationErrors();
    if (validationError) {
      this.error = validationError;
      return;
    }

    // Validate that all content sections have both heading and content
    for (let i = 0; i < this.contentSections.length; i++) {
      const section = this.contentSections[i];
      if (!section.heading || !section.heading.trim()) {
        this.error = `Content section ${i + 1}: heading is required`;
        return;
      }
      if (!section.content || !section.content.trim()) {
        this.error = `Content section ${i + 1}: content is required`;
        return;
      }
    }

    if (this.scheduleForLater && !this.form.get('publishDate')?.value) {
      this.error = 'Please set a publish date for scheduled posts';
      return;
    }

    this.savingBlog = true;

    const postData = {
      ...this.form.value,
      contentSections: this.contentSections,
      tags: this.tags,
      scheduleForLater: this.scheduleForLater,
      socialMeta: this.socialMeta,
      readTime: this.getReadingTime(),
      wordCount: this.totalWordCount
    };

    const request = this.isEdit
      ? this.blogService.updatePost(this.postId!, postData)
      : this.blogService.createPost(postData);

    request.subscribe({
      next: (response) => {
        this.success = this.isEdit ? 'Post updated successfully!' : 'Post created successfully!';
        this.savingBlog = false;
        this.stopAutoSave();

        // Redirect to manage blog page after success
        setTimeout(() => {
          this.router.navigate(['/admin/blog']);
        }, 1000);
      },
      error: (error) => {
        // Extract error message from various possible response formats
        let errorMsg = 'Failed to save blog post';
        
        if (error.error?.message) {
          errorMsg = error.error.message;
        } else if (error.error?.errors && Array.isArray(error.error.errors)) {
          // Express-validator format
          errorMsg = error.error.errors.map((e: any) => e.msg).join(', ');
        } else if (error.message) {
          errorMsg = error.message;
        }
        
        this.error = errorMsg;
        this.savingBlog = false;
        console.error('Error saving post:', error);
        console.error('Full error response:', error.error);
      }
    });
  }

  cancel(): void {
    this.stopAutoSave();
    this.router.navigate(['/admin/blog']);
  }

  /**
   * Get specific form validation error messages
   */
  private getFormValidationErrors(): string | null {
    if (this.form.invalid) {
      const errors: string[] = [];

      // Check each form control for validation errors
      const fieldLabels: { [key: string]: string } = {
        'title': 'Title',
        'subtitle': 'Subtitle',
        'author': 'Author',
        'category': 'Category',
        'introText': 'Introduction text',
        'featuredImage': 'Featured image',
        'publishDate': 'Publish date'
      };

      Object.keys(this.form.controls).forEach(key => {
        const control = this.form.get(key);
        if (control && control.errors) {
          const fieldLabel = fieldLabels[key] || key.charAt(0).toUpperCase() + key.slice(1);
          
          if (control.errors['required']) {
            errors.push(`${fieldLabel} is required`);
          } else if (control.errors['minlength']) {
            const minLength = control.errors['minlength'].requiredLength;
            errors.push(`${fieldLabel} must be at least ${minLength} characters`);
          } else if (control.errors['maxlength']) {
            const maxLength = control.errors['maxlength'].requiredLength;
            errors.push(`${fieldLabel} must not exceed ${maxLength} characters`);
          } else if (control.errors['pattern']) {
            errors.push(`${fieldLabel} format is invalid`);
          }
        }
      });

      if (this.contentSections.length === 0) {
        errors.push('At least one content section is required');
      }

      return errors.length > 0 ? errors.join('; ') : null;
    }

    return null;
  }

  // Word Count Calculations
  calculateWordCounts(): void {
    const introWords = this.countWords(this.form.get('introText')?.value || '');
    const sectionWords = this.contentSections.map(section => 
      this.countWords(section.heading + ' ' + section.content)
    );
    this.sectionWordCounts = sectionWords;
    this.totalWordCount = introWords + sectionWords.reduce((a, b) => a + b, 0);
  }

  private countWords(text: string): number {
    if (!text || typeof text !== 'string') return 0;
    return text.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  // Auto-save Functionality
  startAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }

    this.autoSaveInterval = setInterval(() => {
      this.performAutoSave();
    }, this.AUTO_SAVE_INTERVAL);
  }

  stopAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
  }

  private performAutoSave(): void {
    if (this.form.invalid || !this.form.get('title')?.value) {
      return;
    }

    this.autoSaving = true;
    const postData = {
      ...this.form.value,
      contentSections: this.contentSections,
      tags: this.tags,
      socialMeta: this.socialMeta
    };

    this.blogService.autoSavePost(this.postId, postData).subscribe({
      next: (response) => {
        const data = response.data as BlogPost;
        if (!this.isEdit && data && '_id' in data) {
          // First auto-save creates the draft
          this.isEdit = true;
          this.postId = (data as BlogPost)._id;
        }
        this.lastAutoSaveTime = new Date().toLocaleTimeString();
        this.autoSaving = false;
      },
      error: (error) => {
        console.error('Auto-save error:', error);
        this.autoSaving = false;
      }
    });
  }

  // Preview Functionality
  togglePreview(): void {
    this.showPreview = !this.showPreview;
  }

  closePreview(): void {
    this.showPreview = false;
  }

  // Scheduled Publishing
  toggleScheduleForLater(): void {
    if (!this.scheduleForLater) {
      this.form.patchValue({ publishDate: '' });
    }
  }

  // Open date/time picker
  openDatePicker(): void {
    const dateInput = document.getElementById('publishDate') as HTMLInputElement;
    if (dateInput) {
      dateInput.focus();
      dateInput.showPicker?.();
    }
  }

  // Auto-generate Meta Description from Intro Text
  private autoGenerateMetaDescription(): void {
    const introText = this.form.get('introText')?.value || '';
    
    // Stop auto-generating if intro text is empty
    if (!introText) {
      return;
    }

    // Only auto-generate if user hasn't manually edited the meta description
    if (!this.metaDescriptionAutoGenerated) {
      return;
    }

    // Take first 160 characters, trim to last complete word
    let metaDescription = introText.substring(0, 160);
    
    // If we truncated, find the last space and trim to word boundary
    if (introText.length > 160) {
      const lastSpace = metaDescription.lastIndexOf(' ');
      if (lastSpace > 0) {
        metaDescription = metaDescription.substring(0, lastSpace);
      }
      metaDescription += '...';
    }

    // Update the meta description
    this.form.patchValue({ metaDescription }, { emitEvent: false });
  }

  // Track manual meta description edits
  onMetaDescriptionChange(): void {
    this.metaDescriptionAutoGenerated = false;
  }

  // SEO Preview Methods
  calculateSEOScore(): void {
    const title = this.form.get('title')?.value || '';
    const metaDescription = this.form.get('metaDescription')?.value || '';
    const introText = this.form.get('introText')?.value || '';
    const slug = this.generateSlug(title);

    this.previewSlug = slug;

    let score = 0;
    const suggestions: SEOSuggestion[] = [];

    const titleLength = title.length;
    const descriptionLength = metaDescription.length;

    // Title validation
    if (title) {
      score += 25;
      if (titleLength >= 30 && titleLength <= 60) {
        score += 15;
        suggestions.push({
          type: 'success',
          message: 'Title length is optimal'
        });
      } else if (titleLength < 30) {
        suggestions.push({
          type: 'warning',
          message: `Title is too short (${titleLength}/30 recommended)`,
          suggestion: 'Add more descriptive keywords to your title'
        });
      } else if (titleLength > 60) {
        suggestions.push({
          type: 'warning',
          message: `Title is too long (${titleLength}/60 max)`,
          suggestion: 'Shorten the title for better search visibility'
        });
      }
    } else {
      suggestions.push({
        type: 'error',
        message: 'Title is missing',
        suggestion: 'Add a compelling title for your post'
      });
    }

    // Meta description validation
    if (metaDescription) {
      score += 25;
      if (descriptionLength >= 120 && descriptionLength <= 160) {
        score += 15;
        suggestions.push({
          type: 'success',
          message: 'Meta description length is optimal'
        });
      } else if (descriptionLength < 120) {
        suggestions.push({
          type: 'warning',
          message: `Description is too short (${descriptionLength}/120 recommended)`,
          suggestion: 'Make your description more descriptive'
        });
      } else if (descriptionLength > 160) {
        suggestions.push({
          type: 'warning',
          message: `Description is too long (${descriptionLength}/160 max)`,
          suggestion: 'Trim your description for better display in search results'
        });
      }
    } else {
      suggestions.push({
        type: 'warning',
        message: 'Meta description is missing',
        suggestion: 'Add a compelling description for search results'
      });
    }

    // Slug validation
    if (slug && slug.length > 0) {
      score += 10;
      suggestions.push({
        type: 'success',
        message: 'URL slug is auto-generated'
      });
    }

    // Keyword presence
    const titleLower = title.toLowerCase();
    const descLower = metaDescription.toLowerCase();
    const introLower = introText.toLowerCase();

    if (descLower && titleLower && descLower.includes(titleLower.split(' ')[0])) {
      score += 10;
      suggestions.push({
        type: 'success',
        message: 'Keywords appear in title and description'
      });
    }

    // Content quality
    if (introText && introText.length >= 100) {
      score += 10;
      suggestions.push({
        type: 'success',
        message: 'Good introduction content for SEO'
      });
    } else if (introText) {
      suggestions.push({
        type: 'warning',
        message: 'Introduction text is too short',
        suggestion: 'Expand your intro with more context'
      });
    }

    // Publish status
    const published = this.form.get('published')?.value;
    if (published) {
      score += 5;
    }

    // Ensure score doesn't exceed 100
    score = Math.min(100, score);

    // Determine level
    let level: 'excellent' | 'good' | 'fair' | 'poor';
    if (score >= 80) level = 'excellent';
    else if (score >= 60) level = 'good';
    else if (score >= 40) level = 'fair';
    else level = 'poor';

    this.seoScore = {
      score,
      level,
      suggestions,
      titleLength,
      descriptionLength
    };
  }

  generateSlug(title: string): string {
    return title
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50);
  }

  autoGenerateSEODescription(): void {
    const introText = this.form.get('introText')?.value || '';
    if (!introText) return;

    let metaDescription = introText.substring(0, 160);
    if (introText.length > 160) {
      const lastSpace = metaDescription.lastIndexOf(' ');
      if (lastSpace > 0) {
        metaDescription = metaDescription.substring(0, lastSpace);
      }
      metaDescription += '...';
    }

    this.form.patchValue({ metaDescription }, { emitEvent: true });
    this.metaDescriptionAutoGenerated = true;
  }

  copyToMetaFields(): void {
    const title = this.form.get('title')?.value || '';
    const introText = this.form.get('introText')?.value || '';

    if (!title) {
      this.error = 'Title is required to generate SEO fields';
      return;
    }

    this.form.patchValue({
      metaDescription: this.generateMetaDescription(introText)
    }, { emitEvent: true });

    this.calculateSEOScore();
    this.success = 'SEO fields updated from content';
    setTimeout(() => this.success = null, 3000);
  }

  private generateMetaDescription(introText: string): string {
    if (!introText) return '';
    let description = introText.substring(0, 160);
    if (introText.length > 160) {
      const lastSpace = description.lastIndexOf(' ');
      if (lastSpace > 0) {
        description = description.substring(0, lastSpace);
      }
      description += '...';
    }
    return description;
  }

  toggleSEOPreview(): void {
    this.showSEOPreview = !this.showSEOPreview;
    if (this.showSEOPreview) {
      this.calculateSEOScore();
    }
  }

  getSEOScoreClass(): string {
    if (!this.seoScore) return '';
    switch (this.seoScore.level) {
      case 'excellent': return 'score-excellent';
      case 'good': return 'score-good';
      case 'fair': return 'score-fair';
      case 'poor': return 'score-poor';
      default: return '';
    }
  }

  getSEOScoreIcon(): string {
    if (!this.seoScore) return '';
    switch (this.seoScore.level) {
      case 'excellent': return '🟢';
      case 'good': return '🟢';
      case 'fair': return '🟡';
      case 'poor': return '🔴';
      default: return '';
    }
  }

  // Social Meta Tags Methods
  toggleSocialPreview(): void {
    this.showSocialPreview = !this.showSocialPreview;
    if (this.showSocialPreview) {
      this.generateAndSetSocialMeta(this.form.value);
    }
  }

  generateAndSetSocialMeta(post: any): void {
    this.socialMeta = this.blogService.generateSocialMeta(post);
    if (!this.useCustomSocialImage) {
      this.socialImagePreview = post.featuredImage || null;
      this.socialMeta.ogImage = this.socialImagePreview || '';
      this.socialMeta.twitterImage = this.socialImagePreview || '';
      this.socialMeta.linkedinImage = this.socialImagePreview || '';
    }
  }

  autoFillSocialMeta(): void {
    const post = this.form.value;
    this.generateAndSetSocialMeta(post);
    this.success = 'Social meta tags auto-filled from content';
    setTimeout(() => this.success = null, 3000);
  }

  setSocialPlatform(platform: 'facebook' | 'twitter' | 'linkedin'): void {
    this.activeSocialPlatform = platform;
  }

  onSocialImageSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) return;

    const file = input.files[0];
    const reader = new FileReader();
    reader.onload = () => {
      this.socialImagePreview = reader.result as string;
      this.useCustomSocialImage = true;
      this.updateAllSocialImages(this.socialImagePreview);
    };
    reader.readAsDataURL(file);
  }

  updateAllSocialImages(image: string): void {
    this.socialMeta.ogImage = image;
    this.socialMeta.twitterImage = image;
    this.socialMeta.linkedinImage = image;
  }

  resetSocialImageToDefault(): void {
    this.useCustomSocialImage = false;
    this.socialImagePreview = this.form.get('featuredImage')?.value || null;
    this.updateAllSocialImages(this.socialImagePreview || '');
  }

  getSocialPlatformData(platform: 'facebook' | 'twitter' | 'linkedin'): { title: string; description: string; image: string } {
    switch (platform) {
      case 'twitter':
        return {
          title: this.socialMeta.twitterTitle || '',
          description: this.socialMeta.twitterDescription || '',
          image: this.socialMeta.twitterImage || ''
        };
      case 'linkedin':
        return {
          title: this.socialMeta.linkedinTitle || '',
          description: this.socialMeta.linkedinDescription || '',
          image: this.socialMeta.linkedinImage || ''
        };
      case 'facebook':
      default:
        return {
          title: this.socialMeta.ogTitle || '',
          description: this.socialMeta.ogDescription || '',
          image: this.socialMeta.ogImage || ''
        };
    }
  }

  updateSocialField(platform: 'facebook' | 'twitter' | 'linkedin', field: 'title' | 'description', value: string): void {
    switch (platform) {
      case 'twitter':
        if (field === 'title') this.socialMeta.twitterTitle = value;
        else this.socialMeta.twitterDescription = value;
        break;
      case 'linkedin':
        if (field === 'title') this.socialMeta.linkedinTitle = value;
        else this.socialMeta.linkedinDescription = value;
        break;
      case 'facebook':
        if (field === 'title') this.socialMeta.ogTitle = value;
        else this.socialMeta.ogDescription = value;
        break;
    }
  }

  // JSON-LD Schema Preview Methods
  toggleJSONLDPreview(): void {
    this.showJSONLDPreview = !this.showJSONLDPreview;
    if (this.showJSONLDPreview) {
      this.generateJSONLDPreview();
    }
  }

  generateJSONLDPreview(): void {
    const formValue = this.form.value;
    const schema = this.blogService.generateJSONLD(formValue);
    this.jsonLdPreviewRaw = JSON.stringify(schema);
    this.jsonLdPreviewFormatted = JSON.stringify(schema, null, 2);
  }

  copyJSONLDToClipboard(): void {
    navigator.clipboard.writeText(this.jsonLdPreviewFormatted).then(() => {
      const message = this.success;
      this.success = 'JSON-LD copied to clipboard!';
      setTimeout(() => {
        this.success = message;
      }, 2000);
    }).catch(() => {
      this.error = 'Failed to copy to clipboard';
    });
  }

  // Helper Functions
  private formatDateForInput(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }

  getReadingTime(): number {
    return Math.max(1, Math.ceil(this.totalWordCount / 200));
  }

  // Revision History Methods
  selectRevision(revision: PostRevision): void {
    this.selectedRevision = revision;
  }

  restoreRevision(): void {
    if (!this.selectedRevision || !this.postId) return;

    if (!confirm('Are you sure you want to restore this revision? Your current changes will be replaced.')) {
      return;
    }

    this.restoring = true;
    this.blogService.restorePostRevision(this.postId, this.selectedRevision._id).subscribe({
      next: (response) => {
        this.success = 'Revision restored successfully';
        this.selectedRevision = null;
        this.loadRevisions();
        this.loadPost();
        this.restoring = false;
        setTimeout(() => {
          this.success = null;
        }, 3000);
      },
      error: (error) => {
        this.error = 'Failed to restore revision';
        this.restoring = false;
        console.error('Error restoring revision:', error);
      }
    });
  }

  getSummaryOfChanges(revision: PostRevision): string {
    if (!revision.changes || revision.changes.length === 0) {
      return 'No changes tracked';
    }
    const fields = revision.changes.map(c => c.field).join(', ');
    return `${revision.changes.length} field${revision.changes.length !== 1 ? 's' : ''} changed: ${fields}`;
  }

  getRevisionTypeLabel(type: string): string {
    switch (type) {
      case 'autosave': return 'Auto-saved';
      case 'scheduled_publish': return 'Scheduled';
      default: return 'Edited';
    }
  }

  toggleRevisionHistory(): void {
    this.showRevisionHistory = !this.showRevisionHistory;
  }

  logout(): void {
    this.authService.logout();
    this.router.navigate(['/admin-login']);
  }
}