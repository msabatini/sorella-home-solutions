import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { BlogService, BlogPost, PostRevision } from '../../services/blog.service';

interface ContentSection {
  heading: string;
  content: string;
}

@Component({
  selector: 'app-admin-blog-form',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './admin-blog-form.component.html',
  styleUrls: ['./admin-blog-form.component.scss']
})
export class AdminBlogFormComponent implements OnInit, OnDestroy {
  form!: FormGroup;
  isEdit = false;
  postId: string | null = null;
  loading = false;
  submitted = false;
  error: string | null = null;
  success: string | null = null;
  savingBlog = false;
  autoSaving = false;
  lastAutoSaveTime: string | null = null;

  imagePreview: string | null = null;
  fileUploadError: string | null = null;

  contentSections: ContentSection[] = [{ heading: '', content: '' }];
  tags: string[] = [];
  tagInput = '';

  showPreview = false;
  scheduleForLater = false;
  autoSaveInterval: any = null;
  AUTO_SAVE_INTERVAL = 60000; // Auto-save every 60 seconds

  totalWordCount = 0;
  sectionWordCounts: number[] = [0];
  
  metaDescriptionAutoGenerated = true; // Track if meta was auto-generated

  // Revision history
  revisions: PostRevision[] = [];
  revisionsLoading = false;
  showRevisionHistory = false;
  selectedRevision: PostRevision | null = null;
  restoring = false;

  categories = [
    'Seasonal Care',
    'Move Management',
    'Home Care',
    'Concierge',
    'Corporate Relocation',
    'Tips & Advice'
  ];

  constructor(
    private formBuilder: FormBuilder,
    private blogService: BlogService,
    private route: ActivatedRoute,
    private router: Router
  ) {}

  ngOnInit(): void {
    this.initializeForm();
    this.calculateWordCounts();

    this.route.params.subscribe(params => {
      if (params['id'] && params['id'] !== 'new') {
        this.isEdit = true;
        this.postId = params['id'];
        this.loadPost();
      } else {
        // For new posts, start autosave after form is initialized
        this.startAutoSave();
      }
    });

    // Set up word count calculations and meta description auto-generation
    this.form.valueChanges.subscribe(() => {
      this.calculateWordCounts();
    });

    // Auto-generate meta description from intro text
    this.form.get('introText')?.valueChanges.subscribe(() => {
      this.autoGenerateMetaDescription();
    });
  }

  ngOnDestroy(): void {
    this.stopAutoSave();
  }

  initializeForm(): void {
    this.form = this.formBuilder.group({
      title: ['', [Validators.required, Validators.minLength(5), Validators.maxLength(200)]],
      subtitle: ['', [Validators.required, Validators.minLength(5), Validators.maxLength(300)]],
      author: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      category: ['', Validators.required],
      featuredImage: ['', Validators.required],
      introText: ['', [Validators.required, Validators.minLength(10), Validators.maxLength(1000)]],
      metaDescription: ['', [Validators.maxLength(160)]],
      published: [true],
      publishDate: [''],
      featured: [false]
    });
  }

  loadPost(): void {
    this.loading = true;
    this.error = null;

    this.blogService.getPost(this.postId!).subscribe({
      next: (response) => {
        // Handle both response formats (with or without data wrapper)
        const post = response.data || response;
        
        if (!post || !post.title) {
          throw new Error('Invalid post data');
        }

        this.form.patchValue({
          title: post.title,
          subtitle: post.subtitle || '',
          author: post.author || '',
          category: post.category || '',
          featuredImage: post.featuredImage || '',
          introText: post.introText || '',
          metaDescription: post.metaDescription || '',
          published: post.published !== undefined ? post.published : true,
          publishDate: post.publishDate ? this.formatDateForInput(new Date(post.publishDate)) : '',
          featured: post.featured || false
        });

        this.imagePreview = post.featuredImage || null;
        this.contentSections = post.contentSections && post.contentSections.length > 0 
          ? post.contentSections 
          : [{ heading: '', content: '' }];
        this.tags = post.tags || [];
        this.scheduleForLater = !!post.publishDate;
        this.lastAutoSaveTime = post.lastAutoSavedAt ? new Date(post.lastAutoSavedAt).toLocaleString() : null;
        
        // If the post has a meta description, treat it as manually edited
        this.metaDescriptionAutoGenerated = !post.metaDescription;

        this.calculateWordCounts();
        this.startAutoSave();
        this.loadRevisions();
        this.loading = false;
      },
      error: (error) => {
        this.error = 'Failed to load blog post. The post may have been deleted.';
        this.loading = false;
        console.error('Error loading post:', error);
      }
    });
  }

  loadRevisions(): void {
    if (!this.postId || this.postId === 'new') return;

    this.revisionsLoading = true;
    this.blogService.getPostRevisions(this.postId).subscribe({
      next: (response) => {
        this.revisions = response.data || [];
        this.revisionsLoading = false;
      },
      error: (error) => {
        console.error('Error loading revisions:', error);
        this.revisionsLoading = false;
      }
    });
  }

  get f() {
    return this.form.controls;
  }

  onImageSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];

    if (!file) return;

    // Validate file type
    if (!file.type.startsWith('image/')) {
      this.fileUploadError = 'Please select a valid image file';
      return;
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      this.fileUploadError = 'File size must be less than 5MB';
      return;
    }

    this.fileUploadError = null;

    // Create preview
    const reader = new FileReader();
    reader.onload = () => {
      this.imagePreview = reader.result as string;
      this.form.patchValue({ featuredImage: this.imagePreview });
    };
    reader.readAsDataURL(file);
  }

  removeImage(): void {
    this.imagePreview = null;
    this.form.patchValue({ featuredImage: '' });
  }

  addTag(): void {
    const tag = this.tagInput.trim();
    if (tag && !this.tags.includes(tag)) {
      this.tags.push(tag);
      this.tagInput = '';
    }
  }

  removeTag(tag: string): void {
    this.tags = this.tags.filter(t => t !== tag);
  }

  addContentSection(): void {
    this.contentSections.push({ heading: '', content: '' });
  }

  removeContentSection(index: number): void {
    if (this.contentSections.length > 1) {
      this.contentSections.splice(index, 1);
    }
  }

  updateContentSection(index: number, field: 'heading' | 'content', value: string): void {
    this.contentSections[index][field] = value;
  }

  saveBlog(): void {
    this.submitted = true;
    this.error = null;
    this.success = null;

    if (this.form.invalid || this.contentSections.length === 0) {
      this.error = 'Please fill in all required fields';
      return;
    }

    if (this.scheduleForLater && !this.form.get('publishDate')?.value) {
      this.error = 'Please set a publish date for scheduled posts';
      return;
    }

    this.savingBlog = true;

    const postData = {
      ...this.form.value,
      contentSections: this.contentSections,
      tags: this.tags,
      scheduleForLater: this.scheduleForLater
    };

    const request = this.isEdit
      ? this.blogService.updatePost(this.postId!, postData)
      : this.blogService.createPost(postData);

    request.subscribe({
      next: (response) => {
        this.success = this.isEdit ? 'Post updated successfully!' : 'Post created successfully!';
        this.savingBlog = false;
        this.stopAutoSave();

        setTimeout(() => {
          this.router.navigate(['/admin/blog']);
        }, 1500);
      },
      error: (error) => {
        this.error = error.error?.message || 'Failed to save blog post';
        this.savingBlog = false;
        console.error('Error saving post:', error);
      }
    });
  }

  cancel(): void {
    this.stopAutoSave();
    this.router.navigate(['/admin/blog']);
  }

  // Word Count Calculations
  calculateWordCounts(): void {
    const introWords = this.countWords(this.form.get('introText')?.value || '');
    const sectionWords = this.contentSections.map(section => 
      this.countWords(section.heading + ' ' + section.content)
    );
    this.sectionWordCounts = sectionWords;
    this.totalWordCount = introWords + sectionWords.reduce((a, b) => a + b, 0);
  }

  private countWords(text: string): number {
    if (!text || typeof text !== 'string') return 0;
    return text.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  // Auto-save Functionality
  startAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }

    this.autoSaveInterval = setInterval(() => {
      this.performAutoSave();
    }, this.AUTO_SAVE_INTERVAL);
  }

  stopAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
  }

  private performAutoSave(): void {
    if (this.form.invalid || !this.form.get('title')?.value) {
      return;
    }

    this.autoSaving = true;
    const postData = {
      ...this.form.value,
      contentSections: this.contentSections,
      tags: this.tags
    };

    this.blogService.autoSavePost(this.postId, postData).subscribe({
      next: (response) => {
        const data = response.data as BlogPost;
        if (!this.isEdit && data && '_id' in data) {
          // First auto-save creates the draft
          this.isEdit = true;
          this.postId = (data as BlogPost)._id;
        }
        this.lastAutoSaveTime = new Date().toLocaleTimeString();
        this.autoSaving = false;
      },
      error: (error) => {
        console.error('Auto-save error:', error);
        this.autoSaving = false;
      }
    });
  }

  // Preview Functionality
  togglePreview(): void {
    this.showPreview = !this.showPreview;
  }

  closePreview(): void {
    this.showPreview = false;
  }

  // Scheduled Publishing
  toggleScheduleForLater(): void {
    if (!this.scheduleForLater) {
      this.form.patchValue({ publishDate: '' });
    }
  }

  // Open date/time picker
  openDatePicker(): void {
    const dateInput = document.getElementById('publishDate') as HTMLInputElement;
    if (dateInput) {
      dateInput.focus();
      dateInput.showPicker?.();
    }
  }

  // Auto-generate Meta Description from Intro Text
  private autoGenerateMetaDescription(): void {
    const introText = this.form.get('introText')?.value || '';
    
    // Stop auto-generating if intro text is empty
    if (!introText) {
      return;
    }

    // Only auto-generate if user hasn't manually edited the meta description
    if (!this.metaDescriptionAutoGenerated) {
      return;
    }

    // Take first 160 characters, trim to last complete word
    let metaDescription = introText.substring(0, 160);
    
    // If we truncated, find the last space and trim to word boundary
    if (introText.length > 160) {
      const lastSpace = metaDescription.lastIndexOf(' ');
      if (lastSpace > 0) {
        metaDescription = metaDescription.substring(0, lastSpace);
      }
      metaDescription += '...';
    }

    // Update the meta description
    this.form.patchValue({ metaDescription }, { emitEvent: false });
  }

  // Track manual meta description edits
  onMetaDescriptionChange(): void {
    this.metaDescriptionAutoGenerated = false;
  }

  // Helper Functions
  private formatDateForInput(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }

  getReadingTime(): number {
    return Math.max(1, Math.ceil(this.totalWordCount / 200));
  }

  // Revision History Methods
  selectRevision(revision: PostRevision): void {
    this.selectedRevision = revision;
  }

  restoreRevision(): void {
    if (!this.selectedRevision || !this.postId) return;

    if (!confirm('Are you sure you want to restore this revision? Your current changes will be replaced.')) {
      return;
    }

    this.restoring = true;
    this.blogService.restorePostRevision(this.postId, this.selectedRevision._id).subscribe({
      next: (response) => {
        this.success = 'Revision restored successfully';
        this.selectedRevision = null;
        this.loadRevisions();
        this.loadPost();
        this.restoring = false;
        setTimeout(() => {
          this.success = null;
        }, 3000);
      },
      error: (error) => {
        this.error = 'Failed to restore revision';
        this.restoring = false;
        console.error('Error restoring revision:', error);
      }
    });
  }

  getSummaryOfChanges(revision: PostRevision): string {
    if (!revision.changes || revision.changes.length === 0) {
      return 'No changes tracked';
    }
    const fields = revision.changes.map(c => c.field).join(', ');
    return `${revision.changes.length} field${revision.changes.length !== 1 ? 's' : ''} changed: ${fields}`;
  }

  getRevisionTypeLabel(type: string): string {
    switch (type) {
      case 'autosave': return 'Auto-saved';
      case 'scheduled_publish': return 'Scheduled';
      default: return 'Edited';
    }
  }

  toggleRevisionHistory(): void {
    this.showRevisionHistory = !this.showRevisionHistory;
  }
}